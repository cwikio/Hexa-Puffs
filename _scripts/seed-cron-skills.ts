#!/usr/bin/env npx tsx
/**
 * Seed script for Annabelle cron skills.
 *
 * Creates 7 scheduled skills in the Memorizer DB via the Orchestrator's
 * /tools/call endpoint.  All skills are seeded as `enabled: false` so
 * they auto-enable once the Inngest scheduler detects that their
 * required_tools are available in the ToolRouter.
 *
 * Usage:
 *   npx tsx _scripts/seed-cron-skills.ts
 *
 * Prerequisites:
 *   - Orchestrator running on localhost:8010
 *   - Memorizer MCP connected to Orchestrator
 */

import { readFileSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

const ORCHESTRATOR_URL = process.env.ORCHESTRATOR_URL || 'http://localhost:8010';

// Read auth token (generated by start-all.sh, saved to ~/.annabelle/annabelle.token)
let ANNABELLE_TOKEN = process.env.ANNABELLE_TOKEN || '';
if (!ANNABELLE_TOKEN) {
  try {
    ANNABELLE_TOKEN = readFileSync(join(homedir(), '.annabelle', 'annabelle.token'), 'utf-8').trim();
  } catch {
    console.warn('Warning: No ANNABELLE_TOKEN env var and ~/.annabelle/annabelle.token not found. Requests may fail with 401.');
  }
}

interface CronSkill {
  name: string;
  description: string;
  trigger_config: Record<string, unknown>;
  instructions: string;
  required_tools: string[];
  max_steps: number;
}

const skills: CronSkill[] = [
  {
    name: 'Email Processor',
    description: 'Pull new emails, classify by priority, enrich with contact/project context, and send a smart summary.',
    trigger_config: { interval_minutes: 60 },
    instructions: `You are running the Email Processor skill.

Step 1: Call gmail_get_new_emails to get unprocessed emails. If none, respond "No new emails since last check." and stop.

Step 2: Call memory_list_contacts (no filters) to get ALL known contacts.

Step 3: Call memory_list_projects with status "active" to get all active projects.

Step 4: Now process the emails using the data you already have. For each email:
- Match the sender email against your contacts list.
- If the contact has type "ignored", or if any contact has email matching "@" + the sender's domain with type "ignored" ‚Üí skip silently.
- If the sender is a known contact (type "work"/"personal"), note their name/company/role.
- If the sender is NOT in contacts ‚Üí mark as UNKNOWN. Extract company name from email domain (part between @ and last dot, capitalize first letter, e.g. john@acmecorp.com ‚Üí "Acmecorp").
- For unknown senders, check if their presumed company matches any active project. If not ‚Üí mark as NEW COMPANY.
- Classify each email: urgent (action today), important (this week), informational (FYI), low-priority (newsletters/automated).

Step 5: Format summary grouped by priority:
- "X new emails (Y urgent, Z important)"
- URGENT first with sender, subject, one-line summary
- IMPORTANT next
- Brief count of informational/low-priority
- Note any emails needing a reply

Step 6: If there are UNKNOWN senders, append:
"üìá New senders I don't know:
- [Name] ([email]) ‚Äî subject: [subject]
Who are they? Say 'ignore [name]' or 'ignore @domain.com' to skip them permanently."

Step 7: If there are NEW COMPANIES, append:
"üè¢ New companies:
- [Company Name] (from [sender]'s email)
Is this a project? Should I track it? Is the name correct?"

Keep it concise for Telegram.`,
    required_tools: ['gmail_get_new_emails', 'memory_list_contacts', 'memory_list_projects'],
    max_steps: 15,
  },
  {
    name: 'Morning Briefing',
    description: 'Daily morning overview: calendar, unread emails, pending items, meeting prep.',
    trigger_config: { schedule: '0 6 * * *', timezone: 'America/New_York' },
    instructions: `You are running the Morning Briefing skill. Produce a comprehensive daily overview.

Steps:
1. Get today's date and format it nicely.
2. Call gmail_list_events for today's events across all accounts.
3. Call gmail_get_new_emails to check for unprocessed overnight emails.
4. Call memory_list_projects with status "active" to see current projects.
5. Call memory_list_facts to check for any pending action items or reminders.

Format the briefing:
- "Good morning! Here's your briefing for [date]:"
- CALENDAR: List today's events with times. Flag any that start in the next 2 hours. Note if events have video call links.
- EMAILS: Summarize any unprocessed emails (count, key senders, urgent items).
- PROJECTS: Brief status of active projects ‚Äî any deadlines approaching?
- ACTION ITEMS: Any pending follow-ups or tasks from stored facts.
- HEADS UP: Anything notable (back-to-back meetings, conflicts, heavy schedule).

Keep it actionable and scannable.`,
    required_tools: ['gmail_list_events', 'gmail_get_new_emails', 'memory_list_projects', 'memory_list_facts'],
    max_steps: 15,
  },
  {
    name: 'Evening Recap',
    description: 'Daily evening wrap-up: what happened today, pending items, tomorrow preview.',
    trigger_config: { schedule: '0 18 * * *', timezone: 'America/New_York' },
    instructions: `You are running the Evening Recap skill. Summarize the day and preview tomorrow.

Steps:
1. Get today's date.
2. Call gmail_list_events for today to see what meetings happened.
3. Call gmail_list_events for tomorrow to preview.
4. Call gmail_list_emails with query "in:sent" for today's sent emails to track what was done.
5. Call memory_list_facts for any pending items or follow-ups.

Format the recap:
- "Evening recap for [date]:"
- TODAY: What meetings happened, key emails sent/received.
- PENDING: Items that still need attention (unreplied emails, open tasks).
- TOMORROW: Preview of tomorrow's calendar. Flag early meetings or heavy schedule.
- SUGGESTIONS: "Consider replying to X before tomorrow's meeting" or similar actionable tips.

Keep it brief ‚Äî this is a wind-down summary, not a full report.`,
    required_tools: ['gmail_list_events', 'gmail_list_emails', 'memory_list_facts'],
    max_steps: 12,
  },
  {
    name: 'Weekly Digest',
    description: 'Sunday evening weekly summary and next week preview.',
    trigger_config: { schedule: '0 18 * * 0', timezone: 'America/New_York' },
    instructions: `You are running the Weekly Digest skill. Produce a week-in-review summary.

Steps:
1. Calculate this week's date range (Monday to Sunday).
2. Call gmail_list_events for the past week to see all meetings.
3. Call gmail_list_emails with query "after:[monday] before:[sunday]" to get email volume.
4. Call memory_list_projects with status "active" for project updates.
5. Call gmail_list_events for next week to preview.

Format the digest:
- "Weekly digest: [date range]"
- THIS WEEK: Meeting count, key meetings, email volume, notable exchanges.
- PROJECTS: Status of each active project ‚Äî any progress or blockers?
- NEXT WEEK: Preview of next week's calendar. Flag busy days, important meetings.
- FOLLOW-UPS: Any items that carried over and need attention next week.

This is the big-picture view ‚Äî focus on patterns and priorities, not individual emails.`,
    required_tools: ['gmail_list_events', 'gmail_list_emails', 'memory_list_projects'],
    max_steps: 15,
  },
  {
    name: 'Follow-up Tracker',
    description: 'Check for sent emails that have not received a reply in 48+ hours.',
    trigger_config: { schedule: '0 9 * * *', timezone: 'America/New_York' },
    instructions: `You are running the Follow-up Tracker skill. Find emails you sent that haven't been replied to.

Steps:
1. Calculate the date 48 hours ago.
2. Call gmail_list_emails with query "in:sent after:[4 days ago] before:[2 days ago]" to find sent emails in the 48h+ window.
3. For each sent email found:
   a. Check if there's a reply by searching for the thread or subject.
   b. Look up the recipient via memory_list_contacts to add context.
   c. Check if the recipient is linked to any active projects via memory_list_projects.
4. Filter to only emails without replies.

Format the report:
- If no pending follow-ups: "No pending follow-ups ‚Äî all caught up!"
- Otherwise: "Follow-up needed ([count] emails without reply):"
  - For each: recipient name (company/project if known), subject, days since sent.
  - Suggest: "Draft a follow-up?" for each.

Focus on work emails ‚Äî skip newsletters, automated notifications, etc.`,
    required_tools: ['gmail_list_emails', 'memory_list_contacts', 'memory_list_projects'],
    max_steps: 10,
  },
  {
    name: 'Pre-meeting Prep',
    description: 'Prepare context briefings for meetings starting in the next 30 minutes.',
    trigger_config: { interval_minutes: 15 },
    instructions: `You are running the Pre-meeting Prep skill. Check for meetings starting soon and prepare context.

Steps:
1. Call gmail_list_events for today.
2. Filter to events starting in the next 30 minutes that haven't started yet.
3. If no upcoming meetings, respond with "No meetings in the next 30 minutes." and stop.
4. For each upcoming meeting:
   a. Extract attendee emails from the event.
   b. Look up each attendee via memory_list_contacts.
   c. Find related projects via memory_list_projects (by contact_id or company).
   d. Search recent emails with attendees via gmail_list_emails (last 7 days).
   e. Check for relevant facts via memory_list_facts.
   f. Check if the event description contains a video call link (Zoom, Google Meet, Teams).

Format the prep:
- "Meeting in [X] minutes: [event title]"
- ATTENDEES: Who's in the meeting (name, role, company).
- CONTEXT: Related projects, recent email exchanges, relevant facts.
- TALKING POINTS: Key topics based on recent communication.
- JOIN LINK: Video call link if found in event description.

Keep each briefing focused and actionable.`,
    required_tools: ['gmail_list_events', 'memory_list_contacts', 'memory_list_projects', 'gmail_list_emails', 'memory_list_facts'],
    max_steps: 10,
  },
  {
    name: 'Meeting Overload Warning',
    description: 'Warn about tomorrow having too many meetings or a heavy schedule.',
    trigger_config: { schedule: '0 20 * * *', timezone: 'America/New_York' },
    instructions: `You are running the Meeting Overload Warning skill. Check if tomorrow's schedule is too heavy.

Steps:
1. Call gmail_list_events for tomorrow.
2. Count the total number of meetings and total meeting hours.
3. Check for:
   - More than 5 meetings in a day
   - More than 6 hours of meetings total
   - Back-to-back meetings (less than 15 min gap)
   - Meetings spanning lunch hour (12:00-13:00) without a break
   - Very early (before 8:00) or very late (after 18:00) meetings

Format:
- If schedule looks fine: "Tomorrow's schedule looks manageable ([X] meetings, [Y] hours)." and stop.
- If overloaded: "Schedule warning for tomorrow:"
  - Total meetings and hours
  - Flag specific issues (back-to-back, no lunch break, etc.)
  - Suggest: "Consider rescheduling [meeting] to free up a break?"

Only notify if there's actually something to warn about.`,
    required_tools: ['gmail_list_events'],
    max_steps: 6,
  },
];

const UPDATE_MODE = process.argv.includes('--update');

async function callOrchestrator(toolName: string, args: Record<string, unknown>): Promise<{ success: boolean; data?: Record<string, unknown>; error?: string }> {
  const headers: Record<string, string> = { 'Content-Type': 'application/json' };
  if (ANNABELLE_TOKEN) {
    headers['X-Annabelle-Token'] = ANNABELLE_TOKEN;
  }

  const response = await fetch(`${ORCHESTRATOR_URL}/tools/call`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ name: toolName, arguments: args }),
  });

  if (!response.ok) {
    return { success: false, error: `HTTP ${response.status}: ${response.statusText}` };
  }

  const result = await response.json() as { content?: unknown };
  const content = result.content;
  if (Array.isArray(content)) {
    const textBlock = content.find((b: { type: string }) => b.type === 'text');
    if (textBlock) {
      const parsed = JSON.parse(textBlock.text);
      if (parsed.success) {
        return { success: true, data: parsed.data };
      }
      return { success: false, error: parsed.error || 'Unknown error' };
    }
  }
  return { success: false, error: 'Unexpected response format' };
}

async function findSkillIdByName(name: string): Promise<number | null> {
  const result = await callOrchestrator('memory_list_skills', {
    agent_id: 'thinker',
    trigger_type: 'cron',
  });
  if (!result.success || !result.data) return null;

  const skills = (result.data.skills || []) as Array<{ id: number; name: string }>;
  const match = skills.find((s) => s.name === name);
  return match?.id ?? null;
}

async function updateSkill(skillId: number, skill: CronSkill): Promise<{ success: boolean; error?: string }> {
  return callOrchestrator('memory_update_skill', {
    skill_id: skillId,
    description: skill.description,
    instructions: skill.instructions,
    required_tools: skill.required_tools,
    max_steps: skill.max_steps,
    trigger_config: skill.trigger_config,
  });
}

async function seedSkill(skill: CronSkill): Promise<{ success: boolean; id?: number; error?: string }> {
  const result = await callOrchestrator('memory_store_skill', {
    agent_id: 'thinker',
    name: skill.name,
    description: skill.description,
    trigger_type: 'cron',
    trigger_config: skill.trigger_config,
    instructions: skill.instructions,
    required_tools: skill.required_tools,
    max_steps: skill.max_steps,
    notify_on_completion: true,
    enabled: false,
  });

  if (result.success) {
    return { success: true, id: result.data?.skill_id as number | undefined };
  }
  return { success: false, error: result.error };
}

async function main() {
  if (UPDATE_MODE) {
    console.log(`Updating ${skills.length} cron skills in ${ORCHESTRATOR_URL}...\n`);
  } else {
    console.log(`Seeding ${skills.length} cron skills to ${ORCHESTRATOR_URL}...\n`);
  }

  let created = 0;
  let updated = 0;
  let skipped = 0;
  let failed = 0;

  for (const skill of skills) {
    process.stdout.write(`  ${skill.name}... `);

    if (UPDATE_MODE) {
      // Find existing skill by name and update it
      const skillId = await findSkillIdByName(skill.name);
      if (skillId) {
        const result = await updateSkill(skillId, skill);
        if (result.success) {
          console.log(`updated (id: ${skillId})`);
          updated++;
        } else {
          console.log(`FAILED to update: ${result.error}`);
          failed++;
        }
      } else {
        // Doesn't exist yet ‚Äî create it
        const result = await seedSkill(skill);
        if (result.success) {
          console.log(`created (id: ${result.id})`);
          created++;
        } else {
          console.log(`FAILED: ${result.error}`);
          failed++;
        }
      }
    } else {
      // Default: idempotent seed (skip existing)
      const result = await seedSkill(skill);
      if (result.success) {
        console.log(`created (id: ${result.id})`);
        created++;
      } else if (result.error?.includes('already exists')) {
        console.log('skipped (already exists)');
        skipped++;
      } else {
        console.log(`FAILED: ${result.error}`);
        failed++;
      }
    }
  }

  const parts: string[] = [];
  if (created > 0) parts.push(`${created} created`);
  if (updated > 0) parts.push(`${updated} updated`);
  if (skipped > 0) parts.push(`${skipped} skipped`);
  if (failed > 0) parts.push(`${failed} failed`);
  console.log(`\nDone: ${parts.join(', ')}`);

  if (!UPDATE_MODE) {
    console.log('All new skills seeded as disabled. They will auto-enable when required tools become available.');
  }

  if (failed > 0) {
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('Seed script failed:', error);
  process.exit(1);
});
